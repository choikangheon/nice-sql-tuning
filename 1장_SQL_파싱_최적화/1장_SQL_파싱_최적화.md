# 1장 SQL 처리 과정과 I/O

# SQL

> Structured Query Language → 구조적 질의 언어
>

기본적으로 구조적이고 집합적, 선언적 질의 언어

## 옵티마이저

> 결과 집합을 만드는 과정은 절차적 → 프로시저 필요한데 그것을 만들어 준다


## SQL 최적화 과정

1. SQL 파싱
   사용자로부터 SQL을 받으면 SQL 파서(Parser)가  파싱 진행
    1. 파싱 트리 생성 :  SQL 문을 이루는 개별 구성요소를 분석하여 생성
    2. Syntax 체크 :  문법 오류 체크
    3. Semantic 체크 : 의미상 오류가 없는지 체크 (존재하지 않는 컬럼 접근)
2. SQL 최적화
   옵티마이저(Optimizer) 동작, 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로
   다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나 택
3. 로우 소스 생성
   옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅

## SQL 옵티마이저
> 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS 핵심 엔진

1. 실행된 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아낸다
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 통계 정보를 이용해 각 실행계획의 예상비용 산정
3. 최저 비용을 나타내는 실행계획 선택 

### 실행계획과 비용

  SQL 옵티마이저 == 자동차 네비게이션
왜? 경로 요약이나 모의 주행 같은 기능 보유하고 있고, 예상 최소비용으로 접근할 수 있는 방법 택한다.

### 그럼 항상 최선일까?

SQL 옵티마이저는 대부분 좋은 선택을 하지만, 완벽하지 않다.
쿼리가 복잡할 수록 실수 가능성 높아진다.


## SQL 공유 및 재사용

### 소프트 파싱 vs 하드 파싱

> sql 파싱, 최적화 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시 라고 함'

### SGA (System Global Area)
> 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간

### 최적화 과정
캐시에 o : 사용자 -> SQL 파싱 -> 캐시에 존재하면 바로 실행
캐시에 x : 사용자 -> SQL 파싱 -> 최적화 -> 로우 소스 성생 -> 실행

### 최적화 과정이 하드한 이유
> 내비게이션의 예 : 서울에서 부산까지 모든 이동 경로와 소요 시간을 계산해야 하는데
> 이것은 매우 무거운 작업이다.

그래서 라이브러리 캐쉬가 필요

## 바인드 변수의 중요성

### 이름없는 SQL 문제

  사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 떄 부터 이름을 갖고, 컴파일한 상태로 딕셔너리에 저장되며
사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유

### 그런데 SQL 는 아니다. 왜?

  SQL은 이름이 따로 존재 하지 않고, 전체 SQL 텍스트가 이름 역할
그 이유는 사용자 정의 함수/프로시저 등은 소스가 코드가 바뀌어도 이름이 바뀌지 않아 다른 객체 생성 x
  하지만, SQL 같은 경우 저장하지 않는 이유가 SQL 전체 텍스트가 이름의 역할을 하기에
수정되면 새로운 객체가 생겨나기 떄문이다.
  

### 공유 가능 SQL
> SELECT * FROM review WHERE id = 7900;
> SELECT * FROM REVIEW where ID = 7900;
> 이 두개는 의미는 같지만, 실행할 때 각각 최적화를 진행하고 캐싱함

매 요청마다 하나의 프로시저 생성 예시
```
String sql = "SELECT * FROM product WHERE id = '" + index + "'";
Statement st = con.createStatement();
ResultSet rs = st.executeQuery(sql);
```

매 요청마다 하나의 프로시저 생성 예시
```
String sql = "SELECT * FROM product WHERE id = ?";
PreparedStatement st = con.preparedStatement(sql);
st.setString(1,id);
ResultSet rs = st.executeQuery(sql);
```
